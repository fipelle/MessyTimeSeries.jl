var documenterSearchIndex = {"docs":
[{"location":"man/kalman/#Kalman-filter-and-smoother","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"The Kalman filter and smoother included in this package use symmetric matrices (via LinearAlgebra) and the Joseph's stabilised form. This is particularly beneficial for the stability and speed of estimation algorithms (e.g., the EM algorithm in Shumway and Stoffer, 1982), and to handle high-dimensional forecasting problems.","category":"page"},{"location":"man/kalman/#Types","page":"Kalman filter and smoother","title":"Types","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"The Kalman filter and smoother are controlled by two custom types: KalmanSettings and KalmanStatus. KalmanSettings contains the data, model parameters and a few auxiliary variables useful to speed-up the filtering and smoothing routines. KalmanStatus is an abstract supertype denoting a container for the filter and low-level smoother output. This is specified into the following three structures:","category":"page"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"OnlineKalmanStatus: lightweight and specialised for high-dimensional online filtering problems;\nDynamicKalmanStatus: specialised for filtering and smoothing problems in which the total number of observed time periods can be dynamically changed;\nSizedKalmanStatus: specialised for filtering and smoothing problems in which the total number of observed time periods is fixed to T.","category":"page"},{"location":"man/kalman/#Kalman-filter-and-smoother-input","page":"Kalman filter and smoother","title":"Kalman filter and smoother input","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"KalmanSettings can be constructed field by field or through a series of constructors that require a significantly smaller amount of variables.","category":"page"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"KalmanSettings","category":"page"},{"location":"man/kalman/#MessyTimeSeries.KalmanSettings","page":"Kalman filter and smoother","title":"MessyTimeSeries.KalmanSettings","text":"KalmanSettings(...)\n\nDefine an immutable structure that includes all the Kalman filter and smoother inputs.\n\nModel\n\nThe state space model used below is,\n\nY_t = B*X_t + e_t\n\nX_t = C*X_t-1 + D*U_t\n\nwhere e_t sim N(0_nx1 R) and U_t sim N(0_mx1 Q).\n\nFields\n\nY: Observed measurements (nxT)\nB: Measurement equations' coefficients\nR: Covariance matrix of the measurement equations' error terms\nC: Transition equations' coefficients\nD: Transition equations' coefficients associated to the error terms\nQ: Covariance matrix of the transition equations' error terms\nX0: Mean vector for the states at time t=0\nP0: Covariance matrix for the states at time t=0\nDQD: Covariance matrix of D*U_t (i.e., D*Q*D)\nm: Number of latent states\ncompute_loglik: Boolean (true for computing the loglikelihood in the Kalman filter)\nstore_history: Boolean (true to store the history of the filter and smoother)\n\n\n\n\n\n","category":"type"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"KalmanSettings(Y::Union{FloatMatrix, JMatrix{Float64}}, B::FloatMatrix, R::SymMatrix, C::FloatMatrix, Q::SymMatrix; kwargs...)\nKalmanSettings(Y::Union{FloatMatrix, JMatrix{Float64}}, B::FloatMatrix, R::SymMatrix, C::FloatMatrix, D::FloatMatrix, Q::SymMatrix; kwargs...)\nKalmanSettings(Y::Union{FloatMatrix, JMatrix{Float64}}, B::FloatMatrix, R::SymMatrix, C::FloatMatrix, D::FloatMatrix, Q::SymMatrix, X0::FloatVector, P0::SymMatrix; kwargs...)","category":"page"},{"location":"man/kalman/#MessyTimeSeries.KalmanSettings-Tuple{Union{Matrix{Float64}, Matrix{Union{Missing, Float64}}}, Matrix{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}}","page":"Kalman filter and smoother","title":"MessyTimeSeries.KalmanSettings","text":"KalmanSettings(Y::Union{FloatMatrix, JMatrix{Float64}}, B::FloatMatrix, R::Union{UniformScaling{Float64}, SymMatrix}, C::FloatMatrix, Q::SymMatrix; kwargs...)\n\nKalmanSettings constructor.\n\nArguments\n\nY: Observed measurements (nxT)\nB: Measurement equations' coefficients\nR: Covariance matrix of the measurement equations' error terms\nC: Transition equations' coefficients\nQ: Covariance matrix of the transition equations' error terms\n\nKeyword arguments\n\ncompute_loglik: Boolean (true for computing the loglikelihood in the Kalman filter - default: true)\nstore_history: Boolean (true to store the history of the filter and smoother - default: true)\n\nNotes\n\nThis particular constructor sets D to be an identity matrix, X0 to be a vector of zeros and computes P0 via solve_discrete_lyapunov(C, Q).\n\n\n\n\n\n","category":"method"},{"location":"man/kalman/#MessyTimeSeries.KalmanSettings-Tuple{Union{Matrix{Float64}, Matrix{Union{Missing, Float64}}}, Matrix{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}}","page":"Kalman filter and smoother","title":"MessyTimeSeries.KalmanSettings","text":"KalmanSettings(Y::Union{FloatMatrix, JMatrix{Float64}}, B::FloatMatrix, R::Union{UniformScaling{Float64}, SymMatrix}, C::FloatMatrix, D::FloatMatrix, Q::SymMatrix; kwargs...)\n\nKalmanSettings constructor.\n\nArguments\n\nY: Observed measurements (nxT)\nB: Measurement equations' coefficients\nR: Covariance matrix of the measurement equations' error terms\nC: Transition equations' coefficients\nD: Transition equations' coefficients associated to the error terms\nQ: Covariance matrix of the transition equations' error terms\n\nKeyword arguments\n\ncompute_loglik: Boolean (true for computing the loglikelihood in the Kalman filter - default: true)\nstore_history: Boolean (true to store the history of the filter and smoother - default: true)\n\nNotes\n\nThis particular constructor sets X0 to be a vector of zeros and computes P0 via solve_discrete_lyapunov(C, Q).\n\n\n\n\n\n","category":"method"},{"location":"man/kalman/#MessyTimeSeries.KalmanSettings-Tuple{Union{Matrix{Float64}, Matrix{Union{Missing, Float64}}}, Matrix{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Vector{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}}","page":"Kalman filter and smoother","title":"MessyTimeSeries.KalmanSettings","text":"KalmanSettings(Y::Union{FloatMatrix, JMatrix{Float64}}, B::FloatMatrix, R::Union{UniformScaling{Float64}, SymMatrix}, C::FloatMatrix, D::FloatMatrix, Q::SymMatrix, X0::FloatVector, P0::SymMatrix; kwargs...)\n\nKalmanSettings constructor.\n\nArguments\n\nY: Observed measurements (nxT)\nB: Measurement equations' coefficients\nR: Covariance matrix of the measurement equations' error terms\nC: Transition equations' coefficients\nD: Transition equations' coefficients associated to the error terms\nQ: Covariance matrix of the transition equations' error terms\nX0: Mean vector for the states at time t=0\nP0: Covariance matrix for the states at time t=0\n\nKeyword arguments\n\ncompute_loglik: Boolean (true for computing the loglikelihood in the Kalman filter - default: true)\nstore_history: Boolean (true to store the history of the filter and smoother - default: true)\n\n\n\n\n\n","category":"method"},{"location":"man/kalman/#Kalman-filter-and-low-level-smoother-output","page":"Kalman filter and smoother","title":"Kalman filter and low-level smoother output","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"Each subtype of KalmanStatus can be either initialised manually or through a simplified method. The low-level smoother output are convienent buffer arrays used for low-level matrix operations.","category":"page"},{"location":"man/kalman/#OnlineKalmanStatus","page":"Kalman filter and smoother","title":"OnlineKalmanStatus","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"OnlineKalmanStatus\nOnlineKalmanStatus()","category":"page"},{"location":"man/kalman/#MessyTimeSeries.OnlineKalmanStatus","page":"Kalman filter and smoother","title":"MessyTimeSeries.OnlineKalmanStatus","text":"OnlineKalmanStatus(...)\n\nDefine a mutable structure to handle minimal Kalman filter output. \n\nThe Kalman filter history is not stored. This makes it ideal for online filtering problems. However, it is incompatible with the kalman smoother implementation.\n\nArguments\n\nt: Current point in time\nloglik: Loglikelihood\nX_prior: Latest a-priori X\nX_post: Latest a-posteriori X\nP_prior: Latest a-priori P\nP_post: Latest a-posteriori P\ne: Forecast error\ninv_F: Inverse of the forecast error covariance\nL: Convenient shortcut for the filter and smoother\nbuffer_J1, buffer_J2, buffer_m_m, buffer_m_n_obs: Buffer arrays used for low-level matrix operations \n\n\n\n\n\n","category":"type"},{"location":"man/kalman/#MessyTimeSeries.OnlineKalmanStatus-Tuple{}","page":"Kalman filter and smoother","title":"MessyTimeSeries.OnlineKalmanStatus","text":"OnlineKalmanStatus()\n\nReturn an initialised OnlineKalmanStatus.\n\n\n\n\n\n","category":"method"},{"location":"man/kalman/#DynamicKalmanStatus","page":"Kalman filter and smoother","title":"DynamicKalmanStatus","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"DynamicKalmanStatus\nDynamicKalmanStatus()","category":"page"},{"location":"man/kalman/#MessyTimeSeries.DynamicKalmanStatus","page":"Kalman filter and smoother","title":"MessyTimeSeries.DynamicKalmanStatus","text":"DynamicKalmanStatus(...)\n\nDefine a mutable structure to handle any type of Kalman filter output.\n\nThe Kalman filter history is stored when store_history is set to true in the filter settings.\n\nArguments\n\nt: Current point in time\nloglik: Loglikelihood\nX_prior: Latest a-priori X\nX_post: Latest a-posteriori X\nP_prior: Latest a-priori P\nP_post: Latest a-posteriori P\ne: Forecast error\ninv_F: Inverse of the forecast error covariance\nL: Convenient shortcut for the filter and smoother\nbuffer_J1, buffer_J2, buffer_m_m, buffer_m_n_obs: Buffer arrays used for low-level matrix operations \nhistory_X_prior: History of a-priori X\nhistory_X_post: History of a-posteriori X\nhistory_P_prior: History of a-priori P\nhistory_P_post: History of a-posteriori P\nhistory_e: History of the forecast error\nhistory_inv_F: History of the inverse of the forecast error covariance\nhistory_L: History of the shortcut L\n\n\n\n\n\n","category":"type"},{"location":"man/kalman/#MessyTimeSeries.DynamicKalmanStatus-Tuple{}","page":"Kalman filter and smoother","title":"MessyTimeSeries.DynamicKalmanStatus","text":"DynamicKalmanStatus()\n\nReturn an initialised DynamicKalmanStatus.\n\n\n\n\n\n","category":"method"},{"location":"man/kalman/#SizedKalmanStatus","page":"Kalman filter and smoother","title":"SizedKalmanStatus","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"SizedKalmanStatus\nSizedKalmanStatus(T::Int64)","category":"page"},{"location":"man/kalman/#MessyTimeSeries.SizedKalmanStatus","page":"Kalman filter and smoother","title":"MessyTimeSeries.SizedKalmanStatus","text":"SizedKalmanStatus(...)\n\nDefine an immutable structure that always store the filter history up to time T.\n\nArguments\n\nonline_status: OnlineKalmanStatus struct\nhistory_length: History length\nhistory_X_prior: History of a-priori X\nhistory_X_post: History of a-posteriori X\nhistory_P_prior: History of a-priori P\nhistory_P_post: History of a-posteriori P\nhistory_e: History of the forecast error\nhistory_inv_F: History of the inverse of the forecast error covariance\nhistory_L: History of the shortcut L\n\n\n\n\n\n","category":"type"},{"location":"man/kalman/#MessyTimeSeries.SizedKalmanStatus-Tuple{Int64}","page":"Kalman filter and smoother","title":"MessyTimeSeries.SizedKalmanStatus","text":"SizedKalmanStatus(T::Int64)\n\nReturn an initialised SizedKalmanStatus for some T.\n\n\n\n\n\n","category":"method"},{"location":"man/kalman/#Functions","page":"Kalman filter and smoother","title":"Functions","text":"","category":"section"},{"location":"man/kalman/#Kalman-filter","page":"Kalman filter and smoother","title":"Kalman filter","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"The a-priori prediction and a-posteriori update can be computed for a single point in time via kfilter! or up to T with kfilter_full_sample and kfilter_full_sample!.","category":"page"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"kfilter!\nkfilter_full_sample\nkfilter_full_sample!\nkforecast","category":"page"},{"location":"man/kalman/#MessyTimeSeries.kfilter!","page":"Kalman filter and smoother","title":"MessyTimeSeries.kfilter!","text":"kfilter!(settings::KalmanSettings, status::KalmanStatus)\n\nKalman filter: a-priori prediction and a-posteriori update.\n\nArguments\n\nsettings: KalmanSettings struct\nstatus: KalmanStatus struct\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/#MessyTimeSeries.kfilter_full_sample","page":"Kalman filter and smoother","title":"MessyTimeSeries.kfilter_full_sample","text":"kfilter_full_sample(settings::KalmanSettings, status::KalmanStatus=DynamicKalmanStatus())\n\nRun Kalman filter for t=1 ldots T and return status.\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/#MessyTimeSeries.kfilter_full_sample!","page":"Kalman filter and smoother","title":"MessyTimeSeries.kfilter_full_sample!","text":"kfilter_full_sample!(settings::KalmanSettings, status::SizedKalmanStatus)\n\nRun Kalman filter from t=1 to history_length and update status in-place.\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/#MessyTimeSeries.kforecast","page":"Kalman filter and smoother","title":"MessyTimeSeries.kforecast","text":"kforecast(settings::KalmanSettings, X::Union{FloatVector, Nothing}, h::Int64)\n\nForecast X up to h steps ahead.\n\nArguments\n\nsettings: KalmanSettings struct\nX: State vector\nh: Forecast horizon\nkforecast(settings::KalmanSettings, X::Union{FloatVector, Nothing}, P::Union{SymMatrix, Nothing}, h::Int64)\n\nForecast X and P up to h steps ahead.\n\nArguments\n\nsettings: KalmanSettings struct\nX: State vector\nP: Covariance matrix of the states\nh: Forecast horizon\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/#Kalman-smoother","page":"Kalman filter and smoother","title":"Kalman smoother","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"ksmoother","category":"page"},{"location":"man/kalman/#MessyTimeSeries.ksmoother","page":"Kalman filter and smoother","title":"MessyTimeSeries.ksmoother","text":"ksmoother(settings::KalmanSettings, status::KalmanStatus, t_stop::Int64=1)\n\nKalman smoother: RTS smoother from the last evaluated time period in status up to t==0.\n\nThe smoother is implemented following the approach proposed in Durbin and Koopman (2012).\n\nArguments\n\nsettings: KalmanSettings struct\nstatus: KalmanStatus struct\nt_stop: Optional argument that can be used to define the last smoothing period (default: 1)\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/#Index","page":"Kalman filter and smoother","title":"Index","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"Pages = [\"kalman.md\"]\nDepth = 2","category":"page"},{"location":"man/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"This page contains a few examples to get started with MessyTimeSeries. These examples are based on economic data from FRED, downloaded via FredData. Make sure that your FRED API is accessible to FredData (see here).","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Before getting into the examples, please run the following snippet:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"# Load packages\nusing Dates, DataFrames, LinearAlgebra, Optim, Plots, Measures, StableRNGs;\nusing FredData: Fred, get_data;\nusing MessyTimeSeries;\n\n# Initialise FredData\nf = Fred();\n\n# Download seasonal adjusted (SA) industrial production (IP)\ndates = get_data(f, \"INDPRO\", observation_start=\"1984-01-01\", units=\"lin\").data[!, :date];\nsa_ip = get_data(f, \"INDPRO\", observation_start=\"1984-01-01\", units=\"lin\").data[!, :value];\n\n# Download not seasonally adjusted (NSA) industrial production (IP)\nnsa_ip = get_data(f, \"IPB50001N\", observation_start=\"1984-01-01\", units=\"lin\").data[:, :value];\n\n# Set random seed\nrng = StableRNG(1);","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"note: Advanced estimation and validation algorithms\nAdvanced estimation and validation algorithms are not included in this package, but in MessyTimeSeriesOptim.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"warning: Warning\nPlease note that this tutorial evaluates the following sections in the order reported below.","category":"page"},{"location":"man/getting_started/#Centred-moving-averages","page":"Getting started","title":"Centred moving averages","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Centred moving averages have numerous purposes in time series analysis. MessyTimeSeries has a simple implementation for it. Suppose, for instance, that you are interested in computing the centred moving average of NSA Industrial Production to reduce the effect of seasonality. This can be done running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"nsa_ip_cma = centred_moving_average(permutedims(nsa_ip), 13);\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The size of nsa_ip_cma is identical to the one of the original data, but includes 6 leading and trailing missing observations, since the window is set to 13. The results can be inspected graphically via","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"fig = plot(dates, nsa_ip[:], label=\"Industrial production (NSA)\", legend=:topleft, ylims=(Inf, 120))\nplot!(fig, dates, nsa_ip_cma[:], label=\"Industrial production (NSA, CMA)\", ylims=(Inf, 120));","category":"page"},{"location":"man/getting_started/#Two-sided-interpolation","page":"Getting started","title":"Two-sided interpolation","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"MessyTimeSeries provides two simplified interfaces for interpolating time-series data. More advanced interpolations can be implemented via the state-space modelling functions described in the next section.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"note: Note\nThe following examples remove about 50% of the observed data to produce more evident interpolations graphically.","category":"page"},{"location":"man/getting_started/#Mean-reverting-data","page":"Getting started","title":"Mean-reverting data","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Compute the month-on-month (%) changes of industrial production and input a number of missing observations via","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"# Compute MoM (%) data\nsa_ip_mom = 100*(sa_ip[2:end]./sa_ip[1:end-1] .- 1);\n\n# Populate `missings_coordinates`\nmissings_coordinates = unique(rand(rng, 1:length(sa_ip_mom), 300));\n\n# Input missing observations\nsa_ip_mom_incomplete = permutedims(sa_ip_mom) |> JMatrix{Float64};\nsa_ip_mom_incomplete[1, missings_coordinates] .= missing;\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The function interpolate_series replaces the missing observations with the average of the observed values. Results can be inspected graphically as follows:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"# Interpolate\nsa_ip_mom_interpolated = interpolate_series(sa_ip_mom_incomplete);\n\n# Plots\nfig = plot(dates[2:end], sa_ip_mom, label=\"Industrial production (SA, MoM%)\", legend=:topleft, ylims=(-16, 8));\nplot!(fig, dates[2:end], permutedims(sa_ip_mom_interpolated), label=\"Industrial production (SA, MoM%, interpolated)\", legend=:topleft, ylims=(-16, 8));","category":"page"},{"location":"man/getting_started/#Non-stationary-data","page":"Getting started","title":"Non-stationary data","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Input a number of missing observations to the SA industrial production index via","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"sa_ip_incomplete = permutedims(sa_ip) |> JMatrix{Float64};\nsa_ip_incomplete[1, missings_coordinates] .= missing;\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The function forward_backwards_rw_interpolation interpolates sa_ip_incomplete using a random walk logic both forward and backwards in time. Results can be inspected graphically as follows:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"# Interpolate\nsa_ip_interpolated = forward_backwards_rw_interpolation(sa_ip_incomplete);\n\n# Plots\nfig = plot(dates, sa_ip, label=\"Industrial production (SA)\", legend=:topleft, ylims=(Inf, 120));\nplot!(fig, dates, permutedims(sa_ip_interpolated), label=\"Industrial production (SA, interpolated)\", legend=:topleft, ylims=(Inf, 120));","category":"page"},{"location":"man/getting_started/#Optimal-filtering-and-smoothing","page":"Getting started","title":"Optimal filtering and smoothing","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"A large chunk of this package focusses on optimal filtering and smoothing problems (Anderson and Moore, 2012). This is an elegant way to model time series that show irregularities such as missing observations with applications ranging from real-time forecasting to structural decompositions (see, for instance, Durbin and Koopman, 2012).  ","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"In this short tutorial, I have illustrated a simple way to seasonal adjust non-stationary time series. This should be enough to get the handle of the basic tools included in this package.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"note: Advanced state-space models\nAdvanced state-space models can be easily processed through the functions described below. However, estimating them is often hard, especially with incomplete data. Specialised methods for these problems are implemented in MessyTimeSeriesOptim.","category":"page"},{"location":"man/getting_started/#Seasonal-adjustments","page":"Getting started","title":"Seasonal adjustments","text":"","category":"section"},{"location":"man/getting_started/#Model","page":"Getting started","title":"Model","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Suppose that you would like to seasonally adjust the NSA Industrial Production index. One way to do it is writing a state-space model comprising a trend (mu_t) and a latent component identifying the seasonal factor (gamma_t):","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"beginalignat*2\n    Y_t      = mu_t + gamma_t \n    mu_t    = beta_t-1 + mu_t-1 + u_t qquad u_t sim N(0 sigma_u^2) \n    beta_t  = beta_t-1 + v_t qquad v_t sim N(0 sigma_v^2) \n    gamma_t = sum_j=1^s2 gamma_jt\nendalignat*","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"where","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"beginalignat*2\n    left( beginarrayc gamma_jt  gamma_jt^* endarray right) = left( beginarraycc cos lambda_j  sin lambda_j  -sin lambda_j  cos lambda_j endarray right) left( beginarrayc gamma_jt-1  gamma_jt-1^* endarray right) + left( beginarrayc w_jt  w_jt^* endarray right) qquad left( beginarrayc w_jt  w_jt^* endarray right) sim N(0 sigma_w^2 I)\nendalignat*","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"lambda_j = 2 pi js, s=12, j=1 ldots s2 and t=1 ldots T.","category":"page"},{"location":"man/getting_started/#Estimation","page":"Getting started","title":"Estimation","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note that this model can be written in the compact form","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"beginalignat*2\n    Y_t = B*X_t + e_t \n    X_t = C*X_t-1 + U_t\nendalignat*","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"where e_t sim N(0 10^-4) and U_t sim N(0 Q) building the coefficients via","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"# Convenient function for B\nbuild_B(s::Int64) = hcat([[1.0 0.0] for i=1:1+fld(s,2)]...);\n\n# Convenient functions for C\nbuild_C_gamma_j(λj::Float64) = [cos(λj) sin(λj); -sin(λj) cos(λj)];\nbuild_C_gamma(s::Int64) = cat(dims=[1,2], [build_C_gamma_j(2*pi*j/s) for j=1:fld(s,2)]...);\nbuild_C(s::Int64) = cat(dims=[1,2], [1 1; 0 1], build_C_gamma(s));\n\n# Convenient functions for Q\nbuild_Q_mu_beta(var_mu::Float64, var_beta::Float64) = Diagonal([var_mu, var_beta]) |> Array;\nbuild_Q_gamma(var_gamma::Float64, s::Int64) = Diagonal(kron(var_gamma*ones(fld(s,2)), [1;0])) |> Array;\nbuild_Q(var_mu::Float64, var_beta::Float64, var_gamma::Float64, s::Int64) = cat(dims=[1,2], build_Q_mu_beta(var_mu, var_beta), build_Q_gamma(var_gamma, s));\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The first thing to do for estimating the model using Optim is to define a relevant objective function to minimise. In this tutorial, I have build on the Kalman filter output to perform MLE:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"function fmin(Y::Matrix{Float64}, vec_log_sigma::FloatVector)\n    B = build_B(12);\n    C = build_C(12);\n    R = Symmetric(10^-4*ones(1,1));\n    D = 1.0*Matrix(I, size(B,2), size(B,2));\n    Q = Symmetric(build_Q(exp.(vec_log_sigma)..., 12));\n\n    # Initial conditions\n    X0 = zeros(size(B,2));\n    P0 = Symmetric(1000.0*Matrix(I, size(B,2), size(B,2))); # diffuse initialisation\n\n    # Run Kalman filter and return log-likelihood\n    settings = KalmanSettings(Y, B, R, C, D, Q, X0, P0);\n    status = kfilter_full_sample(settings);\n    return -status.loglik;\nend\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"note: Free parameters\nIn this simple model, the only free parameters are the variances of the trend, drift and seasonal components in the matrix Q.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Next, you need to run an appropriate Optim minimisation algorithm, such as:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"optim_res = optimize(vec_sigma->fmin(permutedims(nsa_ip), vec_sigma), log(0.1)*ones(3), SimulatedAnnealing()); # arbitrary small variances to initialise the model\noptim_res.minimizer, optim_res.minimum","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The optimal model configuration found by Optim is such that:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"B = build_B(12);\nC = build_C(12);\nR = Symmetric(10^-4*ones(1,1));\nD = 1.0*Matrix(I, size(B,2), size(B,2));\nQ = Symmetric(build_Q(exp.(optim_res.minimizer)..., 12));\n\n# Initial conditions\nX0 = zeros(size(B,2));\nP0 = Symmetric(1000.0*Matrix(I, size(B,2), size(B,2))); # diffuse initialisation\n\n# Run Kalman filter and smoother\nsettings = KalmanSettings(permutedims(nsa_ip), B, R, C, D, Q, X0, P0);\nstatus = kfilter_full_sample(settings);\nhistory_X, history_P, X0, P0 = ksmoother(settings, status);\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"p1 = plot(dates, nsa_ip, label=\"Industrial production (NSA)\", legend=:topleft, ylims=(Inf, 120));\nplot!(p1, dates, hcat(history_X...)[1,:], label=\"Industrial production trend\", legend=:topleft, ylims=(Inf, 120));","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"seasonality = sum(hcat(history_X...)[3:end,:], dims=1);\np2 = plot(dates, permutedims(seasonality), label=\"Industrial production seasonality\", legend=:topleft, ylims=(-6, 6))","category":"page"},{"location":"man/methods/#Annex-functions","page":"Annex functions","title":"Annex functions","text":"","category":"section"},{"location":"man/methods/#Functions","page":"Annex functions","title":"Functions","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"This package also includes the following general-purpose functions useful for time series analysis.","category":"page"},{"location":"man/methods/#Building-blocks-for-time-series-algorithms","page":"Annex functions","title":"Building blocks for time series algorithms","text":"","category":"section"},{"location":"man/methods/#Convenient-mathematical-and-statistical-operations","page":"Annex functions","title":"Convenient mathematical and statistical operations","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"no_combinations\nrand_without_replacement\nsoft_thresholding\nsolve_discrete_lyapunov","category":"page"},{"location":"man/methods/#MessyTimeSeries.no_combinations","page":"Annex functions","title":"MessyTimeSeries.no_combinations","text":"no_combinations(n::Int64, k::Int64)\n\nCompute the binomial coefficient of n observations and k groups, for big integers.\n\nExamples\n\njulia> no_combinations(1000000,100000)\n7.333191945934207610471288280331309569215030711272858517142085449641265002716664e+141178\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.rand_without_replacement","page":"Annex functions","title":"MessyTimeSeries.rand_without_replacement","text":"rand_without_replacement(rng::StableRNGs.LehmerRNG, nT::Int64, d::Int64)\n\nDraw length(P)-d elements from the positional vector P without replacement.\n\nP is permanently changed in the process.\n\nExamples\n\njulia> rand_without_replacement(StableRNG(1), 20, 5)\n5-element Array{Int64,1}:\n  1\n  9\n 14\n 19\n 20\n\n\n\n\n\nrand_without_replacement(rng::StableRNGs.LehmerRNG, n::Int64, T::Int64, d::Int64)\n\nDraw length(P)-d elements from the positional vector P without replacement. \n\nIn the sampling process, no more than n-1 elements are removed for each point in time. P is permanently changed in the process.\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.soft_thresholding","page":"Annex functions","title":"MessyTimeSeries.soft_thresholding","text":"soft_thresholding(z::Float64, ζ::Float64)\n\nSoft thresholding operator.\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.solve_discrete_lyapunov","page":"Annex functions","title":"MessyTimeSeries.solve_discrete_lyapunov","text":"solve_discrete_lyapunov(A::AbstractArray{Float64,2}, Q::SymMatrix)\n\nUse a bilinear transformation to convert the discrete Lyapunov equation to a continuous Lyapunov equation, which is then solved using BLAS.\n\nThe notation used for representing the discrete Lyapunov equation is\n\nP - APA = Q,\n\nwhere P and Q are symmetric. This equation is transformed into\n\nBP + PB = -C\n\nReferences\n\nKailath (1980, page 180)\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Convergence-check","page":"Annex functions","title":"Convergence check","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"check_bounds\nisconverged","category":"page"},{"location":"man/methods/#MessyTimeSeries.check_bounds","page":"Annex functions","title":"MessyTimeSeries.check_bounds","text":"check_bounds(X::Real, LB::Real, UB::Real)\n\nCheck whether X is larger or equal than LB and lower or equal than UB\n\n\n\n\n\ncheck_bounds(X::Real, LB::Real)\n\nCheck whether X is larger or equal than LB\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.isconverged","page":"Annex functions","title":"MessyTimeSeries.isconverged","text":"isconverged(new::Float64, old::Float64, tol::Float64, ε::Float64, increasing::Bool)\n\nCheck whether new is close enough to old.\n\nArguments\n\nnew: new objective or loss\nold: old objective or loss\ntol: tolerance\nε: small Float64\nincreasing: true if new increases, at each iteration, with respect to old\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Parameter-transformations","page":"Annex functions","title":"Parameter transformations","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"get_bounded_log\nget_unbounded_log\nget_bounded_logit\nget_unbounded_logit","category":"page"},{"location":"man/methods/#MessyTimeSeries.get_bounded_log","page":"Annex functions","title":"MessyTimeSeries.get_bounded_log","text":"get_bounded_log(Θ_unbound::Float64, MIN::Float64)\n\nCompute parameters with bounded support using a generalised log transformation.\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.get_unbounded_log","page":"Annex functions","title":"MessyTimeSeries.get_unbounded_log","text":"get_unbounded_log(Θ_bound::Float64, MIN::Float64)\n\nCompute parameters with unbounded support using a generalised log transformation.\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.get_bounded_logit","page":"Annex functions","title":"MessyTimeSeries.get_bounded_logit","text":"get_bounded_logit(Θ_unbound::Float64, MIN::Float64, MAX::Float64)\n\nCompute parameters with bounded support using a generalised logit transformation.\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.get_unbounded_logit","page":"Annex functions","title":"MessyTimeSeries.get_unbounded_logit","text":"get_unbounded_logit(Θ_bound::Float64, MIN::Float64, MAX::Float64)\n\nCompute parameters with unbounded support using a generalised logit transformation.\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Sample-statistics-for-incomplete-data","page":"Annex functions","title":"Sample statistics for incomplete data","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"mean_skipmissing\nstd_skipmissing\nsum_skipmissing","category":"page"},{"location":"man/methods/#MessyTimeSeries.mean_skipmissing","page":"Annex functions","title":"MessyTimeSeries.mean_skipmissing","text":"mean_skipmissing(X::AbstractVector{Float64})\nmean_skipmissing(X::AbstractVector{Union{Missing, Float64}})\n\nCompute the mean of the observed values in X.\n\nExamples\n\njulia> mean_skipmissing([1.0; missing; 3.0])\n2.0\n\n\n\n\n\nmean_skipmissing(X::AbstractMatrix{Float64})\nmean_skipmissing(X::AbstractMatrix{Union{Missing, Float64}})\n\nCompute the mean of the observed values in X column wise.\n\nExamples\n\njulia> mean_skipmissing([1.0 2.0; missing 3.0; 3.0 5.0])\n3-element Array{Float64,1}:\n 1.5\n 3.0\n 4.0\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.std_skipmissing","page":"Annex functions","title":"MessyTimeSeries.std_skipmissing","text":"std_skipmissing(X::AbstractVector{Float64})\nstd_skipmissing(X::AbstractVector{Union{Missing, Float64}})\n\nCompute the standard deviation of the observed values in X.\n\nExamples\n\njulia> std_skipmissing([1.0; missing; 3.0])\n1.4142135623730951\n\n\n\n\n\nstd_skipmissing(X::AbstractMatrix{Float64})\nstd_skipmissing(X::AbstractMatrix{Union{Missing, Float64}})\n\nCompute the standard deviation of the observed values in X column wise.\n\nExamples\n\njulia> std_skipmissing([1.0 2.0; missing 3.0; 3.0 5.0])\n3-element Array{Float64,1}:\n   0.7071067811865476\n NaN\n   1.4142135623730951\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.sum_skipmissing","page":"Annex functions","title":"MessyTimeSeries.sum_skipmissing","text":"sum_skipmissing(X::AbstractVector{Float64})\nsum_skipmissing(X::AbstractVector{Union{Missing, Float64}})\n\nCompute the sum of the observed values in X.\n\nExamples\n\njulia> sum_skipmissing([1.0; missing; 3.0])\n4.0\n\n\n\n\n\nsum_skipmissing(X::AbstractMatrix{Float64})\nsum_skipmissing(X::AbstractMatrix{Union{Missing, Float64}})\n\nCompute the sum of the observed values in X column wise.\n\nExamples\n\njulia> sum_skipmissing([1.0 2.0; missing 3.0; 3.0 5.0])\n3-element Array{Float64,1}:\n 3.0\n 3.0\n 8.0\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Time-series-operations","page":"Annex functions","title":"Time-series operations","text":"","category":"section"},{"location":"man/methods/#Foundations","page":"Annex functions","title":"Foundations","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"companion_form\nlag","category":"page"},{"location":"man/methods/#MessyTimeSeries.companion_form","page":"Annex functions","title":"MessyTimeSeries.companion_form","text":"companion_form(Ψ::AbstractArray{Float64,2}; extended::Bool=false)\n\nConstruct the companion form matrix from the generic coefficients Ψ. \n\nIf extended is true, it increases the typical dimension of the companion matrix by n rows.\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.lag","page":"Annex functions","title":"MessyTimeSeries.lag","text":"lag(X::FloatArray, p::Int64)\n\nConstruct the data required to run a standard vector autoregression.\n\nArguments\n\nX: observed measurements (nxT), where n and T are the number of series and observations.\np: number of lags in the vector autoregression\n\nOutput\n\nX_{t}\nX_{t-1}\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Interpolation-and-moving-averages","page":"Annex functions","title":"Interpolation and moving averages","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"centred_moving_average\nforward_backwards_rw_interpolation\ninterpolate_series","category":"page"},{"location":"man/methods/#MessyTimeSeries.centred_moving_average","page":"Annex functions","title":"MessyTimeSeries.centred_moving_average","text":"centred_moving_average(X::Union{FloatMatrix, JMatrix{Float64}}, n::Int64, T::Int64, window::Int64)\n\nCompute the centred moving average of X.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\nwindow is the total number of observations (lagging, current and leading) included in the average\n\n\n\n\n\ncentred_moving_average(X::Union{FloatMatrix, JMatrix{Float64}}, window::Int64)\n\nCompute the centred moving average of X.\n\nArguments\n\nX: observed measurements (nxT)\nwindow is the total number of observations (lagging, current and leading) included in the average\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.forward_backwards_rw_interpolation","page":"Annex functions","title":"MessyTimeSeries.forward_backwards_rw_interpolation","text":"forward_backwards_rw_interpolation(X::JMatrix{Float64}, n::Int64, T::Int64)\n\nInterpolate each non-stationary series in X, in turn, using a random walk logic both forward and backwards in time.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\n\n\n\n\n\nforward_backwards_rw_interpolation(X::FloatMatrix, n::Int64, T::Int64)\n\nReturn X.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\n\n\n\n\n\nforward_backwards_rw_interpolation(X::JMatrix{Float64})\n\nInterpolate each non-stationary series in X, in turn, using a random walk logic both forward and backwards in time.\n\nArguments\n\nX: observed measurements (nxT)\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.interpolate_series","page":"Annex functions","title":"MessyTimeSeries.interpolate_series","text":"interpolate_series(X::JMatrix{Float64}, n::Int64, T::Int64)\n\nInterpolate each series in X, in turn, by replacing missing observations with the sample average of the non-missing values.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\n\n\n\n\n\ninterpolate_series(X::FloatMatrix, n::Int64, T::Int64)\n\nReturn X.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\n\n\n\n\n\ninterpolate_series(X::Union{FloatMatrix, JMatrix{Float64}})\n\nInterpolate each series in X, in turn, by replacing missing observations with the sample average of the non-missing values.\n\nArguments\n\nX: observed measurements (nxT)\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Standardisation","page":"Annex functions","title":"Standardisation","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"demean\nstandardise","category":"page"},{"location":"man/methods/#MessyTimeSeries.demean","page":"Annex functions","title":"MessyTimeSeries.demean","text":"demean(X::FloatVector)\ndemean(X::FloatMatrix)\ndemean(X::JVector{Float64})\ndemean(X::JMatrix{Float64})\n\nDemean X.\n\nExamples\n\njulia> demean([1.0; 1.5; 2.0; 2.5; 3.0])\n5-element Array{Float64,1}:\n -1.0\n -0.5\n  0.0\n  0.5\n  1.0\n\njulia> demean([1.0 3.5 1.5 4.0 2.0; 4.5 2.5 5.0 3.0 5.5])\n2×5 Array{Float64,2}:\n -1.4   1.1  -0.9   1.6  -0.4\n  0.4  -1.6   0.9  -1.1   1.4\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#MessyTimeSeries.standardise","page":"Annex functions","title":"MessyTimeSeries.standardise","text":"standardise(X::FloatVector)\nstandardise(X::FloatMatrix)\nstandardise(X::JVector{Float64})\nstandardise(X::JMatrix{Float64})\n\nStandardise X.\n\nExamples\n\njulia> standardise([1.0; 1.5; 2.0; 2.5; 3.0])\n5-element Array{Float64,1}:\n -1.2649110640673518\n -0.6324555320336759\n  0.0\n  0.6324555320336759\n  1.2649110640673518\n\njulia> standardise([1.0 3.5 1.5 4.0 2.0; 4.5 2.5 5.0 3.0 5.5])\n2×5 Array{Float64,2}:\n -1.08173    0.849934  -0.695401   1.23627   -0.309067\n  0.309067  -1.23627    0.695401  -0.849934   1.08173\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Index","page":"Annex functions","title":"Index","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"Pages = [\"methods.md\"]\nDepth = 2","category":"page"},{"location":"#MessyTimeSeries.jl","page":"MessyTimeSeries.jl","title":"MessyTimeSeries.jl","text":"","category":"section"},{"location":"","page":"MessyTimeSeries.jl","title":"MessyTimeSeries.jl","text":"MessyTimeSeries.jl includes basic tools for time series analysis, compatible with incomplete data.","category":"page"},{"location":"#Outline","page":"MessyTimeSeries.jl","title":"Outline","text":"","category":"section"},{"location":"","page":"MessyTimeSeries.jl","title":"MessyTimeSeries.jl","text":"Pages = [\n    \"man/kalman.md\",\n    \"man/subsampling.md\",\n    \"man/getting_started.md\",\n    \"man/methods.md\",\n]\nDepth = 1","category":"page"},{"location":"man/subsampling/#Subsampling","page":"Subsampling","title":"Subsampling","text":"","category":"section"},{"location":"man/subsampling/#Functions","page":"Subsampling","title":"Functions","text":"","category":"section"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"This package provides a series of methods for partitioning time-series data based on jackkniving and bootstrapping.","category":"page"},{"location":"man/subsampling/#Jackknife","page":"Subsampling","title":"Jackknife","text":"","category":"section"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"The first group of algorithms includes the following generalisation of the jackknife for dependent data:","category":"page"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"the block jackknife (Kunsch, 1989);\nthe artificial delete-d jackknife (Pellegrino, 2022).","category":"page"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"block_jackknife\nartificial_jackknife\noptimal_d","category":"page"},{"location":"man/subsampling/#MessyTimeSeries.block_jackknife","page":"Subsampling","title":"MessyTimeSeries.block_jackknife","text":"block_jackknife(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64)\n\nGenerate block jackknife (Kunsch, 1989) samples. This implementation is described in Pellegrino (2022).\n\nThis technique subsamples a time series dataset by removing, in turn, all the blocks of consecutive observations with a given size.\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: Block size as a percentage of number of observed periods. It is bounded between 0 and 1.\n\nReferences\n\nKunsch (1989) and Pellegrino (2022).\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/#MessyTimeSeries.artificial_jackknife","page":"Subsampling","title":"MessyTimeSeries.artificial_jackknife","text":"artificial_jackknife(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64, max_samples::Int64, seed::Int64=1)\n\nGenerate artificial jackknife samples as in Pellegrino (2022).\n\nThe artificial delete-d jackknife is an extension of the delete-d jackknife for dependent data problems.\n\nThis technique replaces the actual data removal step with a fictitious deletion, which consists of imposing d-dimensional (artificial) patterns of missing observations to the data.\nThis approach does not alter the data order nor destroy the correlation structure.\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: d as a percentage of the original sample size. It is bounded between 0 and 1.\nmax_samples: If binomialnTd is too large, artificial_jackknife generates max_samples jackknife samples.\nseed: Random seed (default: 1).\n\nReferences\n\nPellegrino (2022).\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/#MessyTimeSeries.optimal_d","page":"Subsampling","title":"MessyTimeSeries.optimal_d","text":"optimal_d(n::Int64, T::Int64)\n\nSelect the optimal value for d. See ?artificial_jackknife for more details on d.\n\nArguments\n\nn: Number of series\nT: Number of observations\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/#Bootstrap","page":"Subsampling","title":"Bootstrap","text":"","category":"section"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"The second group includes the following bootstrap versions compatible with time series:","category":"page"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"the moving block bootstrap (Kunsch, 1989; Liu and Singh, 1992);\nthe stationary block bootstrap (Politis and Romano, 1994).","category":"page"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"moving_block_bootstrap\nstationary_block_bootstrap","category":"page"},{"location":"man/subsampling/#MessyTimeSeries.moving_block_bootstrap","page":"Subsampling","title":"MessyTimeSeries.moving_block_bootstrap","text":"moving_block_bootstrap(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64, samples::Int64, seed::Int64=1)\n\nGenerate moving block bootstrap samples.\n\nThe moving block bootstrap randomly subsamples a time series into ordered and overlapped blocks of consecutive observations.\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: Block size as a percentage of number of observed periods. It is bounded between 0 and 1.\nsamples: Number of bootstrap samples.\nseed: Random seed (default: 1).\n\nReferences\n\nKunsch (1989) and Liu and Singh (1992).\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/#MessyTimeSeries.stationary_block_bootstrap","page":"Subsampling","title":"MessyTimeSeries.stationary_block_bootstrap","text":"stationary_block_bootstrap(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64, samples::Int64, seed::Int64=1)\n\nGenerate stationary block bootstrap samples.\n\nThe stationary bootstrap is similar to the block bootstrap proposed in independently in Kunsch (1989) and Liu and Singh (1992).\n\nThere are two main differences:\n\nThe blocks have random length\nIn order to achieve stationarity, the stationary (block) bootstrap \"wraps\" the data around in a \"circle\" so that the first observation follows the last.\n\nNote: Block size is exponentially distributed with mean Int64(ceil(subsample*T)).\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: Block size as a percentage of number of observed periods. It is bounded between 0 and 1.\nsamples: Number of bootstrap samples.\nseed: Random seed (default: 1).\n\nReferences\n\nPolitis and Romano (1994).\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/#Index","page":"Subsampling","title":"Index","text":"","category":"section"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"Pages = [\"subsampling.md\"]\nDepth = 2","category":"page"}]
}
