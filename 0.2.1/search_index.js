var documenterSearchIndex = {"docs":
[{"location":"man/kalman/#Kalman-filter-and-smoother","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"","category":"section"},{"location":"man/kalman/#Index","page":"Kalman filter and smoother","title":"Index","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"Pages = [\"kalman.md\"]\nDepth = 2","category":"page"},{"location":"man/kalman/#Types","page":"Kalman filter and smoother","title":"Types","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"KalmanSettings","category":"page"},{"location":"man/kalman/#MessyTimeSeries.KalmanSettings","page":"Kalman filter and smoother","title":"MessyTimeSeries.KalmanSettings","text":"KalmanSettings(...)\n\nDefine an immutable structure that includes all the Kalman filter and smoother inputs.\n\nModel\n\nThe state space model used below is,\n\nY_t = B*X_t + e_t\n\nX_t = C*X_t-1 + D*U_t\n\nwhere e_t sim N(0_nx1 R) and U_t sim N(0_mx1 Q).\n\nArguments\n\nY: Observed measurements (nxT)\nB: Measurement equations' coefficients\nR: Covariance matrix of the measurement equations' error terms\nC: Transition equations' coefficients\nD: Transition equations' coefficients associated to the error terms\nQ: Covariance matrix of the transition equations' error terms\nX0: Mean vector for the states at time t=0\nP0: Covariance matrix for the states at time t=0\nDQD: Covariance matrix of DU_{t} (i.e., DQ*D')\nm: Number of latent states\ncompute_loglik: Boolean (true for computing the loglikelihood in the Kalman filter)\nstore_history: Boolean (true to store the history of the filter and smoother)\n\n\n\n\n\n","category":"type"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"OnlineKalmanStatus","category":"page"},{"location":"man/kalman/#MessyTimeSeries.OnlineKalmanStatus","page":"Kalman filter and smoother","title":"MessyTimeSeries.OnlineKalmanStatus","text":"OnlineKalmanStatus(...)\n\nDefine a mutable structure to handle minimal Kalman filter output. \n\nThe Kalman filter history is not stored. This makes it ideal for online filtering problems. However, it is incompatible with the kalman smoother implementation.\n\nArguments\n\nt: Current point in time\nloglik: Loglikelihood\nX_prior: Latest a-priori X\nX_post: Latest a-posteriori X\nP_prior: Latest a-priori P\nP_post: Latest a-posteriori P\ne: Forecast error\ninv_F: Inverse of the forecast error covariance\nL: Convenient shortcut for the filter and smoother\nbuffer_J1, buffer_J2, buffer_m_m, buffer_m_n_obs: Buffer arrays used for low-level matrix operations \n\n\n\n\n\n","category":"type"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"DynamicKalmanStatus","category":"page"},{"location":"man/kalman/#MessyTimeSeries.DynamicKalmanStatus","page":"Kalman filter and smoother","title":"MessyTimeSeries.DynamicKalmanStatus","text":"DynamicKalmanStatus(...)\n\nDefine a mutable structure to handle any type of Kalman filter output.\n\nThe Kalman filter history is stored when store_history is set to true in the filter settings.\n\nArguments\n\nt: Current point in time\nloglik: Loglikelihood\nX_prior: Latest a-priori X\nX_post: Latest a-posteriori X\nP_prior: Latest a-priori P\nP_post: Latest a-posteriori P\ne: Forecast error\ninv_F: Inverse of the forecast error covariance\nL: Convenient shortcut for the filter and smoother\nbuffer_J1, buffer_J2, buffer_m_m, buffer_m_n_obs: Buffer arrays used for low-level matrix operations \nhistory_X_prior: History of a-priori X\nhistory_X_post: History of a-posteriori X\nhistory_P_prior: History of a-priori P\nhistory_P_post: History of a-posteriori P\nhistory_e: History of the forecast error\nhistory_inv_F: History of the inverse of the forecast error covariance\nhistory_L: History of the shortcut L\n\n\n\n\n\n","category":"type"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"SizedKalmanStatus","category":"page"},{"location":"man/kalman/#MessyTimeSeries.SizedKalmanStatus","page":"Kalman filter and smoother","title":"MessyTimeSeries.SizedKalmanStatus","text":"SizedKalmanStatus(...)\n\nDefine an immutable structure that always store the filter history up to time T.\n\nArguments\n\nonline_status: OnlineKalmanStatus struct\nhistory_length: History length\nhistory_X_prior: History of a-priori X\nhistory_X_post: History of a-posteriori X\nhistory_P_prior: History of a-priori P\nhistory_P_post: History of a-posteriori P\nhistory_e: History of the forecast error\nhistory_inv_F: History of the inverse of the forecast error covariance\nhistory_L: History of the shortcut L\n\n\n\n\n\n","category":"type"},{"location":"man/kalman/#Functions","page":"Kalman filter and smoother","title":"Functions","text":"","category":"section"},{"location":"man/kalman/#Kalman-filter","page":"Kalman filter and smoother","title":"Kalman filter","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"kfilter!","category":"page"},{"location":"man/kalman/#MessyTimeSeries.kfilter!","page":"Kalman filter and smoother","title":"MessyTimeSeries.kfilter!","text":"kfilter!(settings::KalmanSettings, status::KalmanStatus)\n\nKalman filter: a-priori prediction and a-posteriori update.\n\nArguments\n\nsettings: KalmanSettings struct\nstatus: KalmanStatus struct\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"kfilter_full_sample","category":"page"},{"location":"man/kalman/#MessyTimeSeries.kfilter_full_sample","page":"Kalman filter and smoother","title":"MessyTimeSeries.kfilter_full_sample","text":"kfilter_full_sample(settings::KalmanSettings)\n\nRun Kalman filter from t=1 to T.\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"kfilter_full_sample!","category":"page"},{"location":"man/kalman/#MessyTimeSeries.kfilter_full_sample!","page":"Kalman filter and smoother","title":"MessyTimeSeries.kfilter_full_sample!","text":"kfilter_full_sample!(settings::KalmanSettings, status::SizedKalmanStatus)\n\nRun Kalman filter from t=1 to history_length and update status in-place.\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"kforecast","category":"page"},{"location":"man/kalman/#MessyTimeSeries.kforecast","page":"Kalman filter and smoother","title":"MessyTimeSeries.kforecast","text":"kforecast(settings::KalmanSettings, X::Union{FloatVector, Nothing}, h::Int64)\n\nForecast X up to h-step ahead.\n\nArguments\n\nsettings: KalmanSettings struct\nX: State vector\nh: Forecast horizon\nkforecast(settings::KalmanSettings, X::Union{FloatVector, Nothing}, P::Union{SymMatrix, Nothing}, h::Int64)\n\nForecast X and P up to h-step ahead.\n\nArguments\n\nsettings: KalmanSettings struct\nX: State vector\nP: Covariance matrix of the states\nh: Forecast horizon\n\n\n\n\n\n","category":"function"},{"location":"man/kalman/#Kalman-smoother","page":"Kalman filter and smoother","title":"Kalman smoother","text":"","category":"section"},{"location":"man/kalman/","page":"Kalman filter and smoother","title":"Kalman filter and smoother","text":"ksmoother","category":"page"},{"location":"man/kalman/#MessyTimeSeries.ksmoother","page":"Kalman filter and smoother","title":"MessyTimeSeries.ksmoother","text":"ksmoother(settings::KalmanSettings, status::KalmanStatus, t_stop::Int64=1)\n\nKalman smoother: RTS smoother from the last evaluated time period in status to t==0.\n\nThe smoother is implemented following the approach proposed in Durbin and Koopman (2012).\n\nArguments\n\nsettings: KalmanSettings struct\nstatus: KalmanStatus struct\nt_stop: Optional argument that can be used to define the last smoothing period (default: 1)\n\n\n\n\n\n","category":"function"},{"location":"man/methods/#Annex-functions","page":"Annex functions","title":"Annex functions","text":"","category":"section"},{"location":"man/methods/#Index","page":"Annex functions","title":"Index","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"Pages = [\"methods.md\"]\nDepth = 2","category":"page"},{"location":"man/methods/#Functions","page":"Annex functions","title":"Functions","text":"","category":"section"},{"location":"man/methods/","page":"Annex functions","title":"Annex functions","text":"Modules = [MessyTimeSeries]\nPages   = [\"methods.jl\"]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"man/methods/#MessyTimeSeries.centred_moving_average-Tuple{Union{Matrix{Float64}, Matrix{Union{Missing, Float64}}}, Int64, Int64, Int64}","page":"Annex functions","title":"MessyTimeSeries.centred_moving_average","text":"centred_moving_average(X::Union{FloatMatrix, JMatrix{Float64}}, n::Int64, T::Int64, window::Int64)\n\nCompute the centred moving average of X.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\nwindow is the total number of observations (lagging, current and leading) included in the average\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.check_bounds-Tuple{Real, Real, Real}","page":"Annex functions","title":"MessyTimeSeries.check_bounds","text":"check_bounds(X::Real, LB::Real, UB::Real)\n\nCheck whether X is larger or equal than LB and lower or equal than UB\n\ncheck_bounds(X::Real, LB::Real)\n\nCheck whether X is larger or equal than LB\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.companion_form-Tuple{AbstractMatrix{Float64}}","page":"Annex functions","title":"MessyTimeSeries.companion_form","text":"companion_form(Ψ::AbstractArray{Float64,2}; extended::Bool=false)\n\nConstruct the companion form matrix from the generic coefficients Ψ. \n\nIf extended is true, it increases the typical dimension of the companion matrix by n rows.\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.demean-Tuple{Vector{Float64}}","page":"Annex functions","title":"MessyTimeSeries.demean","text":"demean(X::FloatVector)\ndemean(X::FloatMatrix)\n\nDemean complete data.\n\ndemean(X::JVector{Float64})\ndemean(X::JMatrix{Float64})\n\nDemean incomplete data.\n\nExamples\n\njulia> demean([1.0; 1.5; 2.0; 2.5; 3.0])\n5-element Array{Float64,1}:\n -1.0\n -0.5\n  0.0\n  0.5\n  1.0\n\njulia> demean([1.0 3.5 1.5 4.0 2.0; 4.5 2.5 5.0 3.0 5.5])\n2×5 Array{Float64,2}:\n -1.4   1.1  -0.9   1.6  -0.4\n  0.4  -1.6   0.9  -1.1   1.4\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.error_info-Tuple{Exception}","page":"Annex functions","title":"MessyTimeSeries.error_info","text":"error_info(err::Exception)\nerror_info(err::RemoteException)\n\nReturn error main information\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.forward_backwards_rw_interpolation-Tuple{Matrix{Union{Missing, Float64}}, Int64, Int64}","page":"Annex functions","title":"MessyTimeSeries.forward_backwards_rw_interpolation","text":"forward_backwards_rw_interpolation(X::JMatrix{Float64}, n::Int64, T::Int64)\n\nInterpolate each non-stationary series in X, in turn, using a random walk logic both forward and backwards in time.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\nforwardbackwardsrw_interpolation(X::FloatMatrix, n::Int64, T::Int64)\n\nReturn X.\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.interpolate_series-Tuple{Matrix{Union{Missing, Float64}}, Int64, Int64}","page":"Annex functions","title":"MessyTimeSeries.interpolate_series","text":"interpolate_series(X::JMatrix{Float64}, n::Int64, T::Int64)\n\nInterpolate each series in X, in turn, by replacing missing observations with the sample average of the non-missing values.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\ninterpolate_series(X::FloatMatrix, n::Int64, T::Int64)\n\nReturn X.\n\nArguments\n\nX: observed measurements (nxT)\nn and T are the number of series and observations\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.is_vector_in_matrix-Tuple{Vector{Int64}, Matrix{Int64}}","page":"Annex functions","title":"MessyTimeSeries.is_vector_in_matrix","text":"is_vector_in_matrix(vect::IntVector, matr::IntMatrix)\nis_vector_in_matrix(vect::FloatVector, matr::FloatMatrix)\n\nCheck whether the vector vect is included in the matrix matr.\n\nExamples\n\njulia> isvectorin_matrix([1; 2], [1 2; 2 3]) true\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.isconverged-Tuple{Float64, Float64, Float64, Float64, Bool}","page":"Annex functions","title":"MessyTimeSeries.isconverged","text":"isconverged(new::Float64, old::Float64, tol::Float64, ε::Float64, increasing::Bool)\n\nCheck whether new is close enough to old.\n\nArguments\n\nnew: new objective or loss\nold: old objective or loss\ntol: tolerance\nε: small Float64\nincreasing: true if new increases, at each iteration, with respect to old\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.lag-Tuple{Array{Float64, N} where N, Int64}","page":"Annex functions","title":"MessyTimeSeries.lag","text":"lag(X::FloatArray, p::Int64)\n\nConstruct the data required to run a standard vector autoregression.\n\nArguments\n\nX: observed measurements (nxT), where n and T are the number of series and observations.\np: number of lags in the vector autoregression\n\nOutput\n\nX_{t}\nX_{t-1}\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.mean_skipmissing-Tuple{AbstractVector{Float64}}","page":"Annex functions","title":"MessyTimeSeries.mean_skipmissing","text":"mean_skipmissing(X::AbstractVector{Float64})\nmean_skipmissing(X::AbstractVector{Union{Missing, Float64}})\n\nCompute the mean of the observed values in X.\n\nmean_skipmissing(X::AbstractMatrix{Float64})\nmean_skipmissing(X::AbstractMatrix{Union{Missing, Float64}})\n\nCompute the mean of the observed values in X column wise.\n\nExamples\n\njulia> mean_skipmissing([1.0; missing; 3.0])\n2.0\n\njulia> mean_skipmissing([1.0 2.0; missing 3.0; 3.0 5.0])\n3-element Array{Float64,1}:\n 1.5\n 3.0\n 4.0\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.nan_to_missing!-Tuple{Array{Union{Missing, Float64}, N} where N}","page":"Annex functions","title":"MessyTimeSeries.nan_to_missing!","text":"nan_to_missing!(X::JArray{Float64})\n\nReplace NaN with missing in X.\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.soft_thresholding-Tuple{Float64, Float64}","page":"Annex functions","title":"MessyTimeSeries.soft_thresholding","text":"soft_thresholding(z::Float64, ζ::Float64)\n\nSoft thresholding operator.\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.solve_discrete_lyapunov-Tuple{AbstractMatrix{Float64}, LinearAlgebra.Symmetric{Float64, Matrix{Float64}}}","page":"Annex functions","title":"MessyTimeSeries.solve_discrete_lyapunov","text":"solve_discrete_lyapunov(A::AbstractArray{Float64,2}, Q::SymMatrix)\n\nUse a bilinear transformation to convert the discrete Lyapunov equation to a continuous Lyapunov equation, which is then solved using BLAS.\n\nThe notation used for representing the discrete Lyapunov equation is\n\nP - APA = Q,\n\nwhere P and Q are symmetric. This equation is transformed into\n\nB'P + PB = -C\n\nReferences\n\nKailath (1980, page 180)\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.standardise-Tuple{Vector{Float64}}","page":"Annex functions","title":"MessyTimeSeries.standardise","text":"standardise(X::FloatVector)\nstandardise(X::FloatMatrix)\n\nStandardise complete data.\n\nstandardise(X::JVector{Float64})\nstandardise(X::JMatrix{Float64})\n\nStandardise incomplete data.\n\nExamples\n\njulia> standardise([1.0; 1.5; 2.0; 2.5; 3.0])\n5-element Array{Float64,1}:\n -1.2649110640673518\n -0.6324555320336759\n  0.0\n  0.6324555320336759\n  1.2649110640673518\n\njulia> standardise([1.0 3.5 1.5 4.0 2.0; 4.5 2.5 5.0 3.0 5.5])\n2×5 Array{Float64,2}:\n -1.08173    0.849934  -0.695401   1.23627   -0.309067\n  0.309067  -1.23627    0.695401  -0.849934   1.08173\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.std_skipmissing-Tuple{AbstractVector{Float64}}","page":"Annex functions","title":"MessyTimeSeries.std_skipmissing","text":"std_skipmissing(X::AbstractVector{Float64})\nstd_skipmissing(X::AbstractVector{Union{Missing, Float64}})\n\nCompute the standard deviation of the observed values in X.\n\nstd_skipmissing(X::AbstractMatrix{Float64})\nstd_skipmissing(X::AbstractMatrix{Union{Missing, Float64}})\n\nCompute the standard deviation of the observed values in X column wise.\n\nExamples\n\njulia> std_skipmissing([1.0; missing; 3.0])\n1.4142135623730951\n\njulia> std_skipmissing([1.0 2.0; missing 3.0; 3.0 5.0])\n3-element Array{Float64,1}:\n   0.7071067811865476\n NaN\n   1.4142135623730951\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.sum_skipmissing-Tuple{AbstractVector{Float64}}","page":"Annex functions","title":"MessyTimeSeries.sum_skipmissing","text":"sum_skipmissing(X::AbstractVector{Float64})\nsum_skipmissing(X::AbstractVector{Union{Missing, Float64}})\n\nCompute the sum of the observed values in X.\n\nsum_skipmissing(X::AbstractMatrix{Float64})\nsum_skipmissing(X::AbstractMatrix{Union{Missing, Float64}})\n\nCompute the sum of the observed values in X column wise.\n\nExamples\n\njulia> sum_skipmissing([1.0; missing; 3.0])\n4.0\n\njulia> sum_skipmissing([1.0 2.0; missing 3.0; 3.0 5.0])\n3-element Array{Float64,1}:\n 3.0\n 3.0\n 8.0\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.trimmed_mean-Tuple{AbstractVector{Float64}, Float64}","page":"Annex functions","title":"MessyTimeSeries.trimmed_mean","text":"trimmed_mean(X::AbstractArray{Float64,1}, α::Float64)\n\nCompute the trimmed mean of X (i.e., the sample average of X having removed its α smallest and largest values).\n\n\n\n\n\n","category":"method"},{"location":"man/methods/#MessyTimeSeries.verb_message-Tuple{Bool, String}","page":"Annex functions","title":"MessyTimeSeries.verb_message","text":"verb_message(verb::Bool, message::String)\n\n@info message if verb is true.\n\n\n\n\n\n","category":"method"},{"location":"#MessyTimeSeries.jl","page":"MessyTimeSeries.jl","title":"MessyTimeSeries.jl","text":"","category":"section"},{"location":"","page":"MessyTimeSeries.jl","title":"MessyTimeSeries.jl","text":"MessyTimeSeries.jl includes basic tools for time series analysis, compatible with incomplete data.","category":"page"},{"location":"#Outline","page":"MessyTimeSeries.jl","title":"Outline","text":"","category":"section"},{"location":"","page":"MessyTimeSeries.jl","title":"MessyTimeSeries.jl","text":"Pages = [\n    \"man/kalman.md\",\n    \"man/subsampling.md\",\n    \"man/methods.md\",\n]\nDepth = 1","category":"page"},{"location":"man/subsampling/#Subsampling","page":"Subsampling","title":"Subsampling","text":"","category":"section"},{"location":"man/subsampling/#Index","page":"Subsampling","title":"Index","text":"","category":"section"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"Pages = [\"subsampling.md\"]\nDepth = 2","category":"page"},{"location":"man/subsampling/#Functions","page":"Subsampling","title":"Functions","text":"","category":"section"},{"location":"man/subsampling/#Jackknife","page":"Subsampling","title":"Jackknife","text":"","category":"section"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"block_jackknife","category":"page"},{"location":"man/subsampling/#MessyTimeSeries.block_jackknife","page":"Subsampling","title":"MessyTimeSeries.block_jackknife","text":"block_jackknife(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64)\n\nGenerate block jackknife (Kunsch, 1989) samples. This implementation is described in Pellegrino (2022).\n\nThis technique subsamples a time series dataset by removing, in turn, all the blocks of consecutive observations with a given size.\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: Block size as a percentage of number of observed periods. It is bounded between 0 and 1.\n\nReferences\n\nKunsch (1989) and Pellegrino (2022).\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"artificial_jackknife","category":"page"},{"location":"man/subsampling/#MessyTimeSeries.artificial_jackknife","page":"Subsampling","title":"MessyTimeSeries.artificial_jackknife","text":"artificial_jackknife(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64, max_samples::Int64, seed::Int64=1)\n\nGenerate artificial jackknife samples as in Pellegrino (2022).\n\nThe artificial delete-d jackknife is an extension of the delete-d jackknife for dependent data problems.\n\nThis technique replaces the actual data removal step with a fictitious deletion, which consists of imposing d-dimensional (artificial) patterns of missing observations to the data.\nThis approach does not alter the data order nor destroy the correlation structure.\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: d as a percentage of the original sample size. It is bounded between 0 and 1.\nmax_samples: If C(n*T,d) is large, artificialjackknife would generate `maxsamples` jackknife samples.\nseed: Random seed (default: 1).\n\nReferences\n\nPellegrino (2022).\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"optimal_d","category":"page"},{"location":"man/subsampling/#MessyTimeSeries.optimal_d","page":"Subsampling","title":"MessyTimeSeries.optimal_d","text":"optimal_d(n::Int64, T::Int64)\n\nSelect the optimal value for d. See artificial_jackknife (...) for more details on d.\n\nArguments\n\nn: Number of series\nT: Number of observations\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/#Bootstrap","page":"Subsampling","title":"Bootstrap","text":"","category":"section"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"moving_block_bootstrap","category":"page"},{"location":"man/subsampling/#MessyTimeSeries.moving_block_bootstrap","page":"Subsampling","title":"MessyTimeSeries.moving_block_bootstrap","text":"moving_block_bootstrap(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64, samples::Int64, seed::Int64=1)\n\nGenerate moving block bootstrap samples.\n\nThe moving block bootstrap randomly subsamples a time series into ordered and overlapped blocks of consecutive observations.\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: Block size as a percentage of number of observed periods. It is bounded between 0 and 1.\nsamples: Number of bootstrap samples.\nseed: Random seed (default: 1).\n\nReferences\n\nKunsch (1989) and Liu and Singh (1992).\n\n\n\n\n\n","category":"function"},{"location":"man/subsampling/","page":"Subsampling","title":"Subsampling","text":"stationary_block_bootstrap","category":"page"},{"location":"man/subsampling/#MessyTimeSeries.stationary_block_bootstrap","page":"Subsampling","title":"MessyTimeSeries.stationary_block_bootstrap","text":"stationary_block_bootstrap(Y::Union{FloatMatrix, JMatrix{Float64}}, subsample::Float64, samples::Int64, seed::Int64=1)\n\nGenerate stationary block bootstrap samples.\n\nThe stationary bootstrap is similar to the block bootstrap proposed in independently in Kunsch (1989) and Liu and Singh (1992).\n\nThere are two main differences:\n\nThe blocks have random length\nIn order to achieve stationarity, the stationary (block) bootstrap \"wraps\" the data around in a \"circle\" so that the first observation follows the last.\n\nNote: Block size is exponentially distributed with mean Int64(ceil(subsample*T)).\n\nArguments\n\nY: Observed measurements (nxT), where n and T are the number of series and observations.\nsubsample: Block size as a percentage of number of observed periods. It is bounded between 0 and 1.\nsamples: Number of bootstrap samples.\nseed: Random seed (default: 1).\n\nReferences\n\nPolitis and Romano (1994).\n\n\n\n\n\n","category":"function"}]
}
